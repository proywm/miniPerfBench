You are an expert C++ performance engineer. Optimize the provided code for high compute and resource performance while preserving behavior. The optimized function must keep the exact same signature as the hand-written implementation. If the original file contains explicit template instantiations, reproduce them unchanged at the end of the optimized file. This prompt may include compilation errors, runtime errors or timing data from the previous step. Use it to refine the code. If it is empty, produce an initial optimization based solely on the original source. When refining the code, explore potentially high-reward optimization paths that have not yet been tried and that could yield superior computational performance. Respond only with a JSON object using the keys "optimized_code" and "analysis". The "analysis" field should briefly explain the intent behind your modifications. Additional source files may be provided for context. Here are the files:

// original.cpp
#include "ripser_stub.hpp"

// Original enumerator using push_back for iterator vectors

template <>
class ripser<sparse_distance_matrix>::simplex_coboundary_enumerator {
        index_t idx_below, idx_above, k;
        std::vector<index_t> vertices;
        const diameter_entry_t simplex;
        const coefficient_t modulus;
        const sparse_distance_matrix& dist;
        const binomial_coeff_table& binomial_coeff;
        std::vector<std::vector<index_diameter_t>::const_reverse_iterator> neighbor_it;
        std::vector<std::vector<index_diameter_t>::const_reverse_iterator> neighbor_end;
        index_diameter_t neighbor;

public:
        simplex_coboundary_enumerator(const diameter_entry_t _simplex, const index_t _dim,
                                      const ripser& _parent)
            : idx_below(get_index(_simplex)), idx_above(0), k(_dim + 1), vertices(_dim + 1),
              simplex(_simplex), modulus(_parent.modulus), dist(_parent.dist),
              binomial_coeff(_parent.binomial_coeff) {
                _parent.get_simplex_vertices(idx_below, _dim, _parent.n, vertices.rbegin());

                for (auto v : vertices) {
                        neighbor_it.push_back(dist.neighbors[v].rbegin());
                        neighbor_end.push_back(dist.neighbors[v].rend());
                }
        }

        bool has_next(bool all_cofacets = true) {
                for (auto &it0 = neighbor_it[0], &end0 = neighbor_end[0]; it0 != end0; ++it0) {
                        neighbor = *it0;
                        for (size_t idx = 1; idx < neighbor_it.size(); ++idx) {
                                auto &it = neighbor_it[idx], end = neighbor_end[idx];
                                while (get_index(*it) > get_index(neighbor))
                                        if (++it == end) return false;
                                if (get_index(*it) != get_index(neighbor))
                                        goto continue_outer;
                                else
                                        neighbor = std::max(neighbor, *it);
                        }
                        while (k > 0 && vertices[k - 1] > get_index(neighbor)) {
                                if (!all_cofacets) return false;
                                idx_below -= binomial_coeff(vertices[k - 1], k);
                                idx_above += binomial_coeff(vertices[k - 1], k + 1);
                                --k;
                        }
                        return true;
                continue_outer:;
                }
                return false;
        }

        diameter_entry_t next() {
                ++neighbor_it[0];
                value_t cofacet_diameter = std::max(get_diameter(simplex), get_diameter(neighbor));
                index_t cofacet_index = idx_above + binomial_coeff(get_index(neighbor), k + 1) + idx_below;
                coefficient_t cofacet_coefficient =
                    (k & 1 ? modulus - 1 : 1) * get_coefficient(simplex) % modulus;
                return diameter_entry_t(cofacet_diameter, cofacet_index, cofacet_coefficient);
        }
};

long long run(const sparse_distance_matrix& dist, int repeat) {
    ripser<sparse_distance_matrix> r(dist);
    diameter_entry_t simplex{0.0, 0, 1};
    long long sum = 0;
    for (int i = 0; i < repeat; ++i) {
        ripser<sparse_distance_matrix>::simplex_coboundary_enumerator e(simplex, 2, r);
        while (e.has_next()) sum += get_index(e.next());
    }
    return sum;
}


// ripser_stub.hpp
#pragma once
#include <vector>
#include <utility>
#include <algorithm>
#include <cstddef>

using index_t = std::size_t;
using value_t = double;
using coefficient_t = int;

using index_diameter_t = std::pair<index_t, value_t>;
inline index_t get_index(const index_diameter_t& e) { return e.first; }
inline value_t get_diameter(const index_diameter_t& e) { return e.second; }

struct diameter_entry_t {
    value_t diameter;
    index_t index;
    coefficient_t coefficient;
    diameter_entry_t(value_t d = 0.0, index_t i = 0, coefficient_t c = 0)
        : diameter(d), index(i), coefficient(c) {}
};
inline index_t get_index(const diameter_entry_t& e) { return e.index; }
inline value_t get_diameter(const diameter_entry_t& e) { return e.diameter; }
inline coefficient_t get_coefficient(const diameter_entry_t& e) { return e.coefficient; }

struct sparse_distance_matrix {
    std::vector<std::vector<index_diameter_t>> neighbors;
    size_t size() const { return neighbors.size(); }
};

struct binomial_coeff_table {
    index_t operator()(index_t n, index_t k) const {
        if (k > n) return 0;
        if (k == 0 || k == n) return 1;
        index_t r = 1;
        for (index_t i = 1; i <= k; ++i) r = r * (n - (k - i)) / i;
        return r;
    }
};

template <typename DistanceMatrix>
class ripser {
public:
    const DistanceMatrix& dist;
    const index_t n;
    const coefficient_t modulus = 2;
    binomial_coeff_table binomial_coeff;

    ripser(const DistanceMatrix& d) : dist(d), n(d.size()) {}

    template <typename OutputIt>
    OutputIt get_simplex_vertices(index_t /*idx*/, index_t dim, index_t n_in, OutputIt out) const {
        for (index_t i = 0; i <= dim; ++i) *out++ = (n_in - i - 1);
        return out;
    }

    class simplex_coboundary_enumerator; // defined elsewhere
};

inline sparse_distance_matrix make_matrix(index_t n) {
    sparse_distance_matrix m;
    m.neighbors.resize(n);
    for (index_t i = 0; i < n; ++i) {
        for (index_t j = 0; j < n; ++j) {
            if (i == j) continue;
            m.neighbors[i].push_back({j, static_cast<value_t>(i + j)});
        }
        std::sort(m.neighbors[i].begin(), m.neighbors[i].end(),
                  [](const auto& a, const auto& b) { return get_index(a) < get_index(b); });
    }
    return m;
}


The following files are provided for context. Do NOT modify them. Only update code in original.cpp.

// harness.cpp
#include "ripser_stub.hpp"
#include <chrono>
#include <iostream>
#include <string>

long long run(const sparse_distance_matrix& dist, int repeat);

int main(int argc, char* argv[]) {
    std::string mode = "perf";
    int repeat = 20000000;

    for (int i = 1; i < argc; ++i) {
        std::string arg = argv[i];
        if (arg == "--mode=correct")
            mode = "correct";
        else if (arg == "--mode=perf")
            mode = "perf";
        else if (arg.rfind("--repeat=", 0) == 0)
            repeat = std::stoi(arg.substr(9));
    }

    auto dist = make_matrix(20);

    if (mode == "correct") {
        long long sum = run(dist, 1);
        std::cout << sum << "\n";
    } else {
        using clock = std::chrono::high_resolution_clock;
        auto t1 = clock::now();
        long long sum = run(dist, repeat);
        auto t2 = clock::now();
        std::cout << "Time: "
                  << std::chrono::duration_cast<std::chrono::milliseconds>(t2 - t1).count()
                  << " ms\n";
        if (sum == 42) std::cerr << ""; // prevent optimization
    }
    return 0;
}


// ripser_stub.hpp
#pragma once
#include <vector>
#include <utility>
#include <algorithm>
#include <cstddef>

using index_t = std::size_t;
using value_t = double;
using coefficient_t = int;

using index_diameter_t = std::pair<index_t, value_t>;
inline index_t get_index(const index_diameter_t& e) { return e.first; }
inline value_t get_diameter(const index_diameter_t& e) { return e.second; }

struct diameter_entry_t {
    value_t diameter;
    index_t index;
    coefficient_t coefficient;
    diameter_entry_t(value_t d = 0.0, index_t i = 0, coefficient_t c = 0)
        : diameter(d), index(i), coefficient(c) {}
};
inline index_t get_index(const diameter_entry_t& e) { return e.index; }
inline value_t get_diameter(const diameter_entry_t& e) { return e.diameter; }
inline coefficient_t get_coefficient(const diameter_entry_t& e) { return e.coefficient; }

struct sparse_distance_matrix {
    std::vector<std::vector<index_diameter_t>> neighbors;
    size_t size() const { return neighbors.size(); }
};

struct binomial_coeff_table {
    index_t operator()(index_t n, index_t k) const {
        if (k > n) return 0;
        if (k == 0 || k == n) return 1;
        index_t r = 1;
        for (index_t i = 1; i <= k; ++i) r = r * (n - (k - i)) / i;
        return r;
    }
};

template <typename DistanceMatrix>
class ripser {
public:
    const DistanceMatrix& dist;
    const index_t n;
    const coefficient_t modulus = 2;
    binomial_coeff_table binomial_coeff;

    ripser(const DistanceMatrix& d) : dist(d), n(d.size()) {}

    template <typename OutputIt>
    OutputIt get_simplex_vertices(index_t /*idx*/, index_t dim, index_t n_in, OutputIt out) const {
        for (index_t i = 0; i <= dim; ++i) *out++ = (n_in - i - 1);
        return out;
    }

    class simplex_coboundary_enumerator; // defined elsewhere
};

inline sparse_distance_matrix make_matrix(index_t n) {
    sparse_distance_matrix m;
    m.neighbors.resize(n);
    for (index_t i = 0; i < n; ++i) {
        for (index_t j = 0; j < n; ++j) {
            if (i == j) continue;
            m.neighbors[i].push_back({j, static_cast<value_t>(i + j)});
        }
        std::sort(m.neighbors[i].begin(), m.neighbors[i].end(),
                  [](const auto& a, const auto& b) { return get_index(a) < get_index(b); });
    }
    return m;
}


Previous attempt info:
Original execution time: mean = 3684.60 ms, std = 16.77 ms